

# 🧩 선착순 이벤트 처리 구조 개선기
상황 : 웹사이트 페이지를 방문할 때마다 (ip, url,  시간대) 등 방문기록이 DB테이블에 insert 될때,

1. 선착순 이벤트로 특정 시간에 사용자가 몰릴때 RDB테이블에 짧은 타임에
과도한 insert로 예측되는 문제를 설명하고
2. 해결 방법을 제시
   
### 1️⃣ 문제 상황 

기존에는 **톰캣 스레드(Tomcat thread)** 가

* `손님 응대(이벤트 페이지 로직)`
* `주방 작업(DB insert 로직)`
  을 **모두 직접 처리**하고 있었다.

이때 선착순 이벤트가 열리면 특정 테이블(예: `event_entry`)에
`INSERT` 작업이 폭주하여 **B-Tree 인덱스의 리프 노드 페이지에 락 경쟁**이 발생한다.

* 첫 번째 `INSERT` 작업만 락을 획득하고 수행
* 나머지 `INSERT`들은 **DB 커넥션을 점유한 채 대기 상태**로 머무름
* 그 사이 새로운 `SELECT` 요청(다른 API 호출)이 들어와도
  DB 커넥션 풀에 여유가 없어 **커넥션을 얻지 못하고 대기**
* 결국 **서버 전체가 멈춘 듯한 상태**에 빠짐

즉,

> 톰캣 스레드가 ‘요리(INSERT)’하느라 ‘손님 응대(SELECT)’로 돌아가지 못한 상황이었다. 🍳

---

### 2️⃣ 문제 인식

톰캣 스레드가 동시에

* 주방(DB 작업)
* 홀(사용자 응답)
  을 둘 다 맡으니, 한쪽이 막히면 전체가 정체되는 구조였다.
  이를 해결하기 위해 **역할을 분리**해야 했다.

---

## 3️⃣ 해결 방법 — 솔루션  A : 큐(Queue)와 워커스레드(Worker Thread) 도입

💥 선착순 이벤트 폭주 시 발생 순서

1. 핫스팟 발생: INSERT가 DB 인덱스(B-Tree)의 마지막 리프 노드 페이지("1번 화구")에 몰림

2. 락 점유: "사장님 1"이 "1번 화구"(Lock)를 잡고 요리를 시작

3. 커넥션 고갈: "사장님 2~10"은 락이 풀리길 기다리며 DB 커넥션(냄비) 을 쥔 채 대기

4. 커넥션 풀 소진: "냄비 선반(DB 커넥션 풀)"은 0/10 상태로 고갈

5. 연쇄 붕괴 시작: INSERT와 무관한 SELECT API("샐러드 손님") 도착

6. "사장님 11"은 커넥션이 없어 작업 시작조차 불가

7. 결과: INSERT의 병목이 SELECT까지 마비시키는 연쇄 붕괴 발생

문제의 본질: "사장님(톰캣 스레드)"이 "느린 주방 일(DB 작업)"을 기다리느라
"냄비(DB 커넥션)"를 반납하지 못하고, "빠른 손님 응대(다른 API)"로 돌아가지 못하는 구조적 문제
**핵심 아이디어:**

> 톰캣 스레드는 DB 작업을 직접 하지 않고, “주문서만 큐에 올려두고” 바로 손님에게 응답한다.

1. **톰캣 스레드**

   * 사용자의 `insert` 요청을 받으면,
     작업 내용을 **큐(Queue)** 에 넣고 **즉시 응답** 반환.
   * 따라서 사용자 응답 속도 저하 없이 빠르게 처리 가능.

2. **워커스레드(Worker Thread)**

   * 큐에 쌓인 작업들을 순서대로 꺼내 DB에 반영
   * 각 작업은

     * 커넥션풀에서 커넥션을 **획득 → insert → 반납**
     * 그 다음 작업으로 이동
   * 예를 들어 **워커스레드 1개만** 두면,
     커넥션을 한 번에 하나씩만 사용하므로
     DB 커넥션풀 고갈 문제 해결 ✅

---

### 3️⃣-1 결과

| 문제        | 개선 전                     | 개선 후                |
| --------- | ------------------------ | ------------------- |
| DB 커넥션 고갈 | 여러 톰캣 스레드가 동시에 insert 대기 | 워커 1개가 순차 insert 처리 |
| 사용자 응답 지연 | insert 완료까지 톰캣 스레드 대기    | 큐에 맡기고 즉시 응답        |
| 서버 전체 정체  | insert로 인한 커넥션 점유        | 커넥션 사용 최소화          |

---

### 3️⃣-2 남은 과제

큐로 인해 **DB 커넥션 문제**는 해결되었지만,
여전히 `INSERT` 대상 인덱스 리프 노드가 집중되는 **핫스팟(Hotspot) 병목**은 남아 있다.

또한 `SELECT` 요청은 작업특성상 큐를 타지 않기 때문에,
만약 조회 쿼리 자체가 특정 리소스에 집중되는 경우는 어떻게 할까

---

### ✅ 솔루션 A에 대한 딥다이브

> 톰캣 스레드가 “모든 걸 직접 처리하는 구조”에서
> “큐와 워커스레드로 역할을 분리한 구조”로 바꾸면서
> 응답성 문제와 DB 커넥션 고갈을 효과적으로 해결했다.

이후에는 **DB 인덱스 병목 완화**와
**읽기(SELECT) 트래픽 분산 전략**이 다음 단계 과제로 이어진다.

select작업이 일반적으로 빠른작업으로 알려져있지만, 느린 select작업이라면? select 핫스팟이 일어나면?
<링크>
---

## 4️⃣ 해결 방법 — 솔루션  B:


## 5️⃣ 해결 방법 — 솔루션  C:

## 6️⃣ Trade-off 분석 및 아키텍처 결정 - A B C
